---
title: "Data Science Capstone Data Analysis"
output:
  html_document:
    code_folding: hide
    number_sections: false
    toc: yes
    toc_depth: 3
    toc_float: yes
  pdf_document:
    toc: yes
    toc_depth: '3'
author: "Kyla Mazzotta"
# date: "today"
date: "`r Sys.Date()`"
---

```{r include = FALSE}
#install.packages("jsonlite")
library(jsonlite)
#install.packages("dplyr")
library(dplyr)
#install.packages("purrr")
library(purrr)
#install.packages("stringr")
library(stringr)
#install.packages("readr")
library(readr)
#install.packages("corrplot")
library(corrplot)
#install.packages("ggplot2")
library(ggplot2)
#install.packages("MASS")
library("MASS")
#install.packages("car")
library("car")
#install.packages("broom")
library(broom)
#install.packages("gt")
library(gt)
```


# Data
- A dataset containing web scraped race results from the UTMB website
- Originally a json object, was then loaded before preprocessing
```{r}
utmb_data <- fromJSON("utmb-race-data-raw.json", flatten=TRUE)
```

```{r include = FALSE}
str(utmb_data[[1]])
```

## Data Preprocessing
- Prior research shows that ultra marathons tend to be dominated by American and European athletes as there is little to no monetary incentive to perform well, a key factor differentiating marathon participants from ultra marathon participants.
- The main focus for this statistical analysis was therefore to isolate races that occurred in the United States to reduce potential variability in results across finish times with differen participant demographics country-wise.
- The UTMB race results were then filtered to only contain data on races located in the US
```{r}
us_races <- utmb_data[
  sapply(utmb_data, function(x) {
    grepl("United States|USA|US$", x$`City / Country`, ignore.case = TRUE)
  })
]
```

- The dataset of US races was then converted into a data frame to prepare for exploratory data analysis (EDA)
- The original dataset contained information on the number of participants in. each age 4-year age group. Since the there is little variation in finish times with such small age groups, they were consolidated into three bins:
  - Under 35
  - 35 - 59
  - 60 and older
- Each age group bin was also adjusted to reoprt the percentage of athletes in each age group as opposed to number as the races vary in size and participant breakdowns.

```{r}
us_df <- imap_dfr(us_races, ~{
  results <- .x$Results
  total_age <- sum(unlist(.x$Age))
  tibble(
    race_id        = .y,
    city_country   = .x$`City / Country`,
    date           = .x$Date,
    distance       = .x$Distance,
    elevation_gain = .x$`Elevation Gain`,
    n_participants = length(results),
    mean_time_hrs      = mean(results, na.rm = TRUE),
    median_time_hrs    = median(results, na.rm = TRUE),
    sd_time            = sd(results, na.rm = TRUE),
    min_time_hrs       = min(results, na.rm = TRUE),
    max_time_hrs       = max(results, na.rm = TRUE),
    pct_women      = .x$Sex$Women / sum(unlist(.x$Sex)),
    pct_age_u35     = sum(unlist(.x$Age[c("U18", "U20", "20-34")]), na.rm = TRUE) / total_age,
    pct_age_35_59     = sum(unlist(.x$Age[c("35-39", "40-44", "45-49", "50-54", "55-59")]), na.rm = TRUE) / total_age,
    pct_age_60_plus = sum(unlist(.x$Age[c("60-64", "65-69", "70-74", "75-79", "80+")]), na.rm = TRUE) / total_age
  )
})
```


- Distance and elevation variables were also converted from character strings to variables for analysis.
```{r}
colnames(us_df)[4] <- "distance_km"
colnames(us_df)[5] <- "elevation_gain_m"

us_df <- us_df %>%
  mutate(
    distance_km = parse_number(distance_km),
    elevation_gain_m = parse_number(elevation_gain_m)
  )
```

- UTMB races are not implicitly ultra marathons, therefore race distances vary anywhere from `r min(us_df$distance_km)` to `r max(us_df$distance_km)` kilometers long.
- To ensure that only ultra marathons were being considered, only races with distances greater than or equal to 50 km.
```{r}
us_df <- us_df %>% filter(distance_km >= 50)
```

- Since races also vary in number of participants, it was important to determine what the smallest acceptable race size would be to control for potential extreme results.
- Total numbers of participants varied from 17 to 1842, therefore it was important to eliminate some of the smaller races from the data.

```{r echo = TRUE, results = FALSE}
# min number of participants
min(us_df$n_participants, na.rm = TRUE)
# 1

# max number of participants
max(us_df$n_participants, na.rm = TRUE)
# 1000

# distribution
summary(us_df$n_participants)
```

- The 50th percentile was calculated to be races with `r quantile(us_df$n_participants, 0.5)` participants.
- It was therefore determined that races with `r quantile(us_df$n_participants, 0.5) + 1` or more participants would be analyzed as these races were sufficiently large enough while not eliminating too many data points.

```{r}
us_df <- us_df %>% filter(n_participants >= 85)
```


- The most common ultra marathon races are typically 50 km, 50 mi, 100 km, and 100 mi. Since these distances are never exact, distance (along with elevation gain) were treated as continuous variables, therefore they were centered to measure deviations from the mean to help with:
  - model stability
  - make interpretations of regression coefficients meaningful
  - reducing multicollinearity

```{r}
mean_distance_km <- mean(us_df$distance_km)
mean_elevation_m <- mean(us_df$elevation_gain_m)

us_df$distance_km <- us_df$distance_km - mean_distance_km
us_df$elevation_gain_m <- us_df$elevation_gain_m - mean_elevation_m
```

- After centering, distance and elevation baselines became:
  - `r round(mean_distance_km, 4)` kilometers
  - `r round(mean_elevation_m, 4)` meters


```{r}
# table to show the first 5 rows
table_df <- us_df |>
  dplyr::select(
    race_id,
    mean_time_hrs,
    distance_km,
    elevation_gain_m,
    pct_women,
    pct_age_u35,
    pct_age_35_59,
    pct_age_60_plus
  ) |>
  slice_head(n = 5)

# create pretty table
gt_table <- gt(table_df) |>
  tab_header(
    title = "Sample of UTMB Race-Level Data",
    subtitle = "First 5 Rows — Centered Predictors Included"
  ) |>
  tab_spanner(
    label = "Centered Predictors",
    columns = c(distance_km, elevation_gain_m)
  ) |>
  tab_spanner(
    label = "Participant Demographics (%)",
    columns = c(pct_women, pct_age_u35, pct_age_35_59, pct_age_60_plus)
  ) |>
  cols_label(
    race_id = "Race ID",
    mean_time_hrs = "Mean Finish Time (hrs)",
    distance_km = "Distance (km, centered)",
    elevation_gain_m = "Elevation Gain (m, centered)",
    pct_women = "% Women",
    pct_age_u35 = "Under 35",
    pct_age_35_59 = "35–59",
    pct_age_60_plus = "60+"
  ) |>
  fmt_number(
    columns = c(distance_km, elevation_gain_m, pct_women, pct_age_u35, pct_age_35_59, pct_age_60_plus),
    decimals = 4
  ) |>
  opt_stylize(style = 6, color = "blue") |>
  tab_options(
    heading.align = "center",
    heading.background.color = "grey",
    heading.title.font.size = px(20)
  )

gt_table
```


# Exploratory Data Analysis

## Correlation Matrix
- A correlation matrix was made to determine which factors should be considered for inclusion in regression
- Note that the Under 35 age group is excluded to prevent perfect multicillinearity.
```{r}
correlation_matrix <- us_df %>% dplyr::select(distance_km, elevation_gain_m, pct_women, pct_age_35_59, pct_age_60_plus)

corrplot(cor(correlation_matrix))
```

## Preliminary Scatterplots
- Scatterplots of race distance and elevation against mean finish time were constructed to produce a baseline idea of variable relationships

### Distance vs Mean Finish Time
```{r}
ggplot(us_df, aes(x = distance_km, y = mean_time_hrs)) +
  geom_point(alpha = 0.6, size = 3) +
  geom_smooth(method = "lm", se = FALSE, col = "#f1e60e") +
  labs(
    x = "Race Distance (km)",
    y = "Mean Finish Time (hrs)",
    title = "Race Distance Vs Mean Finish Time"
  ) +
  theme_minimal(base_size = 15)
```

- The scatterplot indicates potential nonlinear relationship between distance and mean finish time.

### Elevation Gain vs Mean Finish Time
```{r}
ggplot(us_df, aes(x = elevation_gain_m, y = mean_time_hrs)) +
  geom_point(alpha = 0.6, size = 3) +
  geom_smooth(method = "lm", se = FALSE, col = "#f1e60e") +
  labs(
    x = "Elevation Gain (m)",
    y = "Mean Finish Time (hrs)",
    title = "Elevation Gain Vs Mean Finish Time"
  ) +
  theme_minimal(base_size = 15)
```

- The scatter plot displays a moderately positive linear relationship between elevation gain and mean with time with a couple potential outliers

# Regression

## Preliminary Regression - Parsimonious Model
remember that we are using pct_u35 as the base so it is not included in models (to avoid perfect multicollinearity)
```{r}
prelim_regression <- lm(mean_time_hrs ~ distance_km + I(distance_km^2) + elevation_gain_m +
                          pct_women + pct_age_35_59 + pct_age_60_plus, data = us_df)
summary(prelim_regression)
```

### Residuals Plots Indicating Non-normality
```{r}
par(mfrow = c(1,2))
plot(prelim_regression, which=1, main="prelim model", pch=20)
plot(prelim_regression, which=2, main="prelim model", pch=20)
```

## Log Model Moving Forward
- Due to the data not appearing to be normally distributed, a log model will be run moving forward.
```{r}
us_df <- us_df %>%
  mutate(log_mean_time = log(mean_time_hrs))
```

### Parsimonious Model
```{r}
log_regression <- lm(log_mean_time ~ distance_km + I(distance_km^2) + elevation_gain_m +
                          pct_women + pct_age_35_59 + pct_age_60_plus, data = us_df)

summary(log_regression)

par(mfrow = c(1,2))
plot(log_regression, which=1, main="prelim model", pch=20)
plot(log_regression, which=2, main="prelim model", pch=20)
```

### Full Model
- Regressions with full model (interaction and higher order terms), adding only terms that are hypothesized to be significant and relevant.
```{r}
full_log_regression <- lm(log_mean_time ~ distance_km + I(distance_km^2) + elevation_gain_m +
                          pct_women + pct_age_35_59 + pct_age_60_plus +
                          distance_km*elevation_gain_m + distance_km*pct_women +
                          elevation_gain_m*pct_women, data = us_df)
summary(full_log_regression)

par(mfrow = c(1,2))
plot(full_log_regression, which=1, main="prelim model", pch=20)
plot(full_log_regression, which=2, main="prelim model", pch=20)
```

```{r include = FALSE}
#regression with reduced model after stepwise backward elimination

log_backward_step_model <- stepAIC(full_log_regression, direction = "backward")

summary(log_backward_step_model)

par(mfrow = c(1,2))
plot(log_backward_step_model, which=1, main="backward", pch=20)
plot(log_backward_step_model, which=2, main="backward", pch=20)

```

### Stepwise Regression (from both directions)
```{r}
log_both_step_model <- stepAIC(full_log_regression, direction = "both")

summary(log_both_step_model)

par(mfrow = c(1,2))
plot(log_both_step_model, which=1, main="both directions", pch=20)
plot(log_both_step_model, which=2, main="both directions", pch=20)
```

#### Checking VIF of Stepwise Regression Model
```{r}
vif(log_backward_step_model, type = "predictor")
```

#### Checking for Outliers
```{r}
cooks_distance <- cooks.distance(log_both_step_model)
threshold <- 4 / nrow(us_df)
influential_observations <- which(cooks_distance > threshold)
```
- Outliers were checked for using Cook's Distance with a threshold criteria of `r round(threshold, 4)`

### Stepwise Regression with Outliers Removed
- Outliers were then removed and stepwise regression from both directions was then run to check model improvement.
```{r}
keep_rows <- which(cooks_distance <= threshold)
us_df_no_outliers <- us_df[keep_rows, ]
```

```{r}
no_outlier_log_regression <- lm(log_mean_time ~ distance_km + I(distance_km^2) + elevation_gain_m +
                          pct_women + pct_age_35_59 + pct_age_60_plus +
                          distance_km*elevation_gain_m + distance_km*pct_women +
                          elevation_gain_m*pct_women, data = us_df_no_outliers)

outlierless_log_both_step_model <- stepAIC(no_outlier_log_regression, direction = "both")

summary(outlierless_log_both_step_model)

par(mfrow = c(1,2))
plot(outlierless_log_both_step_model, which=1, main="both directions", pch=20)
plot(outlierless_log_both_step_model, which=2, main="both directions", pch=20)
```



```{r include = FALSE}
plot(log_both_step_model)

# these clusters are due to the most common distances 50k, 50mi, 100k, and 100mi
# deciding to use the outlier-free model
```

#### VIF Analysis
```{r}
vif(outlierless_log_both_step_model, type = "predictor")
```





```{r include = FALSE}
# scatterplot of distance and time with outliers
ggplot(us_df, aes(x = distance_km, y = mean_time_hrs)) +
  geom_point(alpha = 0.6, size = 3) +
  geom_smooth(method = "lm", se = FALSE, col = "#f1e60e") +
  labs(
    x = "Race Distance (km)",
    y = "Mean Finish Time (hrs)",
    title = "Race Distance Vs Mean Finish Time"
  ) +
  theme_minimal(base_size = 15)
```

```{r include = FALSE}
# scatterplot of distance and time with outliers removed
ggplot(us_df_no_outliers, aes(x = distance_km, y = mean_time_hrs)) +
  geom_point(alpha = 0.6, size = 3) +
  geom_smooth(method = "lm", se = FALSE, col = "#f1e60e") +
  labs(
    x = "Race Distance (km)",
    y = "Mean Finish Time (hrs)",
    title = "Race Distance Vs Mean Finish Time"
  ) +
  theme_minimal(base_size = 15)
```

```{r include = FALSE}
# scatterplot of elevation gain and time (with outliers)
ggplot(us_df, aes(x = elevation_gain_m, y = mean_time_hrs)) +
  geom_point(alpha = 0.6, size = 3) +
  geom_smooth(method = "lm", se = FALSE, col = "#f1e60e") +
  labs(
    x = "Elevation Gain (m)",
    y = "Mean Finish Time (hrs)",
    title = "Elevation Gain Vs Mean Finish Time"
  ) +
  theme_minimal(base_size = 15)
```

```{r include = FALSE}
# scatterplot of elevation gain and time (with outliers removed)
ggplot(us_df_no_outliers, aes(x = elevation_gain_m, y = mean_time_hrs)) +
  geom_point(alpha = 0.6, size = 3) +
  geom_smooth(method = "lm", se = FALSE, col = "#f1e60e") +
  labs(
    x = "Elevation Gain (m)",
    y = "Mean Finish Time (hrs)",
    title = "Elevation Gain Vs Mean Finish Time"
  ) +
  theme_minimal(base_size = 15)
```
